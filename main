#!/bin/bash
VERSION="0.1"
ROOT="$(dirname "$0")"
SELF="$(basename "$0")"


CONFIG_FILE_PATH=".dotman"

function info() {
  version
  echo -e "$SELF is a dotfile managment script inspired by GNU Stow, with added support for symlinking to root directories like /etc or /bin"
  echo -e "$SELF is a (mostly) drop-in replacement of GNU Stow"
  echo
}

function version() {
  echo -e "$SELF version $VERSION"
}

function usage() {
  echo -e "USAGE:\n\n\t$SELF [OPTION ...] [-D|-S|-R] PACKAGE ... [-D|-S|-R] PACKAGE ...\n"
}

function options() {
  echo -e "OPTIONS\n"
  echo -e "\t-d DIR, --dir=DIR\tSet stow dir to DIR (default is current dir)"
  echo -e "\t-t DIR, --target=DIR\tOverride default target to DIR\n\t\t\t\t(configured in the $CONFIG_FILE_PATH file\n\t\t\t\tdefault is \$HOME)"
  echo
  echo -e "\t-S, --stow\t\tStow the package names that follow this option"
  echo -e "\t-D, --delete\t\tUnstow the package names that follow this option"
  echo -e "\t-R, --restow\t\tRestow (like $SELF -D followed by $0 -S)"
  echo
  echo -e "\t--ignore=REGEX\t\tIgnore files ending in this Perl regex"
  echo -e "\t--defer=REGEX\t\tDon't stow files beginning with this Perl regex\n\t\t\t\tif the file is already stowed to another package"
  echo -e "\t--override=REGEX\tForce stowing files beginning with this Perl regex\n\t\t\t\tif the file is already stowed to another package"
  echo -e "\t--adopt\t\t\t(Use with care!) Import existing files into stow\n\t\t\t\tfrom target. Please read docs before using."
  echo -e "\t--dotfiles\t\tEnables special handling for dotfiles that are\n\t\t\t\tStow packages that start with \"dot-\" and not \".\""
  echo -e "\t-p, --compat\t\tUse legacy algorithm for unstowing"
  echo -e "\t-n, --no, --simulate\tDo not actually make any filesystem changes"
  echo -e "\t-v, --verbose[=N]\tIncrease verbosity (levels are from 0 to 5;\n\t\t\t\t -v or --verbose adds 1; --verbose=N sets level)"
  echo
  echo -e "\t-V, --version\t\tShow $SELF version number"
  echo -e "\t-h, --help\t\tShow this help"
}

function help() {
  info
  usage
  options
}

function parse_config() {
  default_value=""
  while IFS= read -r line
  do
    # Trim leading/trailing whitespace using Bash parameter expansion
    line="${line#"${line%%[![:space:]]*}"}"
    line="${line%"${line##*[![:space:]]}"}"

    # Skip empty lines and comments
    [[ -z "$line" || "${line:0:1}" == "#" ]] && continue

    # Split on first '=' only
    IFS='=' read -r key value <<< "$line"

    # Trim spaces around key and value
    key="${key#"${key%%[![:space:]]*}"}"
    key="${key%"${key##*[![:space:]]}"}"
    value="${value#"${value%%[![:space:]]*}"}"
    value="${value%"${value##*[![:space:]]}"}"

    if [[ "$key" == "." ]]; then
      if [[ -z "$TARGET" ]]; then
        default_value="$value"
      else
        default_value="$TARGET"
      fi
    elif [[ "$2" == "$key" ]]; then
      echo "$(echo $value | envsubst)"
      return 0
    fi
  done < "$1/$CONFIG_FILE_PATH"

  echo "$(echo "$default_value" | envsubst)/$2"
}

function unsymlink_directory() {
  local SOURCE="$1"
  local TARGET="$2"
  local IGNORE="$3"
  local DEFER="$4"
  local OVERRIDE="$5"
  local ADOPT="$6"
  local DOTFILES="$7"
  local COMPAT="$8"
  local SIMULATE="$9"
  local VERBOSE="${10}"

  if [ -d "$TARGET" ]; then
    echo "targ is dir $TARGET"
    for directory in $(ls -a $TARGET)
    do
      if [[ "$directory" == "." || "$directory" == ".." ]]; then
        continue
      fi

      unsymlink_directory "$SOURCE" "$TARGET/$directory" "$IGNORE" "$DEFER" "$OVERRIDE" "$ADOPT" "$DOTFILES" "$COMPAT" "$SIMULATE" "$VERBOSE"
    done
  else
    if [ ! -L "$TARGET" ]; then
      echo "targ is not link $TARGET"
      return 0
    fi

    if [[ "$(readlink -f "$(readlink "$TARGET")")" == "$(readlink -f "$SOURCE")"* ]]; then

      if [[ "$SIMULATE" == "1" ]]; then
        if [ "$VERBOSE" -ge 1 ]; then
          echo "UNLINK: $TARGET"
        fi
        return 0
      fi


      result=$(rm "$TARGET" 2>&1)
      status=$?
      echo "status $status"
      return 0

      if [[ $status -eq 1 ]]; then
        if [[ "$result" == "*Permission denied*" ]]; then
          echo "Permission denied: Command found but not executable"
          sudo -E ln -s "$SOURCE" "$TARGET"
          if [[ $? -eq 0 ]]; then
            if [ "$VERBOSE" -ge 1 ]; then
              echo "LINK: $SOURCE => $TARGET"
            fi
          fi
        fi
      #elif [[ $status -eq 127 ]]; then
        #echo "Command not found"
      #elif [[ $status -ne 0 ]]; then
        #echo "Command failed with exit code $status"
      #else
        #echo "Command succeeded"
      else
        if [ "$VERBOSE" -ge 1 ]; then
          echo "LINK: $SOURCE => $TARGET"
        fi
      fi
    fi
  fi
}

function symlink_directory() {
  local SOURCE="$1"
  local TARGET="$2"
  local IGNORE="$3"
  local DEFER="$4"
  local OVERRIDE="$5"
  local ADOPT="$6"
  local DOTFILES="$7"
  local COMPAT="$8"
  local SIMULATE="$9"
  local VERBOSE="${10}"

  if [ -d "$TARGET" ]; then
    for directory in $(ls -a $SOURCE)
    do
      if [[ "$directory" == "." || "$directory" == ".." ]]; then
        continue
      fi

      symlink_directory "$SOURCE/$directory" "$TARGET/$directory" "$IGNORE" "$DEFER" "$OVERRIDE" "$ADOPT" "$DOTFILES" "$COMPAT" "$SIMULATE" "$VERBOSE"
    done
  else
    if [[ "$SIMULATE" == "1" ]]; then
      if [ "$VERBOSE" -ge 1 ]; then
        echo "LINK: $SOURCE => $TARGET"
      fi
      return 0
    fi


    result=$(ln -s "$SOURCE" "$TARGET" 2>&1)
    status=$?

    if [[ $status -eq 1 ]]; then
      if [[ "$result" == "*Permission denied*" ]]; then
        echo "Permission denied: Command found but not executable"
        sudo -E ln -s "$SOURCE" "$TARGET"
        if [[ $? -eq 0 ]]; then
          if [ "$VERBOSE" -ge 1 ]; then
            echo "LINK: $SOURCE => $TARGET"
          fi
        fi
      fi
    #elif [[ $status -eq 127 ]]; then
      #echo "Command not found"
    #elif [[ $status -ne 0 ]]; then
      #echo "Command failed with exit code $status"
    #else
      #echo "Command succeeded"
    else
      if [ "$VERBOSE" -ge 1 ]; then
        echo "LINK: $SOURCE => $TARGET"
      fi
    fi
  fi
}

function unstow() {
  local PACKAGE="$1"
  local DIR="$2"
  local TARGET="$3"
  local IGNORE="$4"
  local DEFER="$5"
  local OVERRIDE="$6"
  local ADOPT="$7"
  local DOTFILES="$8"
  local COMPAT="$9"
  local SIMULATE="${10}"
  local VERBOSE="${11}"

  if [ -d "$DIR/$PACKAGE" ]; then
    for directory in $(ls -a $DIR/$PACKAGE/)
    do
      if [[ "$directory" == "." || "$directory" == ".." ]]; then
        continue
      fi

      directory="$DIR/$PACKAGE/$directory"
      targ="$(parse_config $DIR $(basename "$directory") "$TARGET")"

      echo "unstow source: $directory targ: $targ"
      unsymlink_directory "$directory" "$targ" "$IGNORE" "$DEFER" "$OVERRIDE" "$ADOPT" "$DOTFILES" "$COMPAT" "$SIMULATE" "$VERBOSE"


      #ln -s "$directory" "$targ"
      
    done
  else
    echo "dotman: ERROR: The stow directory $DIR does not contain package $PACKAGE"
    return 1
  fi
}

function stow() {
  local PACKAGE="$1"
  local DIR="$2"
  local TARGET="$3"
  local IGNORE="$4"
  local DEFER="$5"
  local OVERRIDE="$6"
  local ADOPT="$7"
  local DOTFILES="$8"
  local COMPAT="$9"
  local SIMULATE="${10}"
  local VERBOSE="${11}"

  if [ "$VERBOSE" -ge 2 ]; then
    echo "stow dir is $DIR"
    echo "Planning stow of: $PACKAGE ..."
  fi

  if [ -d "$DIR/$PACKAGE" ]; then
    for directory in $(ls -a $DIR/$PACKAGE/)
    do
      if [[ "$directory" == "." || "$directory" == ".." ]]; then
        continue
      fi

      directory="$DIR/$PACKAGE/$directory"
      #mkdir -p "$(realpath "$TARGET")/$(basename "$directory")"
      targ="$(parse_config $DIR $(basename "$directory") "$TARGET")"

      mkdir -p "$targ" &>/dev/null
      symlink_directory "$directory" "$targ" "$IGNORE" "$DEFER" "$OVERRIDE" "$ADOPT" "$DOTFILES" "$COMPAT" "$SIMULATE" "$VERBOSE"


      #ln -s "$directory" "$targ"
      
    done
  else
    echo "dotman: ERROR: The stow directory $DIR does not contain package $PACKAGE"
    return 1
  fi
}




# Main logic
DIR="./"
TARGET=""
IGNORE=""
DEFER=""
OVERRIDE=""
ADOPT=0
DOTFILES=0
COMPAT=0
SIMULATE=0
VERBOSE=0

while [[ "$1" == -* ]]; do
  case "$1" in
  -d)
    shift
    DIR="$1"
    ;;
  --dir=*)
    DIR="${1#*=}"
    ;;
  -t)
    shift
    TARGET="$1"
    ;;
  --target=*)
    TARGET="${1#*=}"
    ;;
  -S|--stow)
    shift
    stow "$1" "$DIR" "$TARGET" "$IGNORE" "$DEFER" "$OVERRIDE" "$ADOPT" "$DOTFILES" "$COMPAT" "$SIMULATE" "$VERBOSE"
    ;;
  -D|--delete)
    shift
    unstow "$1" "$DIR" "$TARGET" "$IGNORE" "$DEFER" "$OVERRIDE" "$ADOPT" "$DOTFILES" "$COMPAT" "$SIMULATE" "$VERBOSE"
    ;;
  -R|--restow)
    shift
    restow "$1" "$DIR" "$TARGET" "$IGNORE" "$DEFER" "$OVERRIDE" "$ADOPT" "$DOTFILES" "$COMPAT" "$SIMULATE" "$VERBOSE"
    ;;
  --ignore=*)
    IGNORE="${1#*=}"
    ;;
  --defer=*)
    DEFER="${1#*=}"
    ;;
  --override)
    OVERRIDE="${1#*=}"
    ;;
  --adopt)
    ADOPT=1
    ;;
  --dotfiles)
    DOTFILES=1
    ;;
  -p|--compat)
    COMPAT=1
    ;;
  -n|--no|--simulate)
    SIMULATE=1
    ;;
  -v*)
    (( VERBOSE += ${#1} - 1 ))
    ;;
  --verbose=*)
    VERBOSE="${1#*=}"
    ;;
  -h|--help)
    help
    exit 0
    ;;
  -V|--version)
    version
    ;;
  --)
    shift
    break
    ;;
  esac
  shift
done

if [ ! -z "$1" ]; then
  stow "$1" "$DIR" "$TARGET" "$IGNORE" "$DEFER" "$OVERRIDE" "$ADOPT" "$DOTFILES" "$COMPAT" "$SIMULATE" "$VERBOSE"
fi


